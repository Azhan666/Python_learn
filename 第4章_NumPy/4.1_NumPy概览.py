# !/usr/bin/env python
# -*- coding: utf-8 -*-
"""第4章_科学计算基础软件包NumPy"""

"""
    NumPy是Python科学计算的基础软件包,提供了多维数组类(numpy.ndarray)及其派生类(掩码数组、
矩阵等),以及用于快速操作数组的函数和API,涵盖基本线性代数、基本统计运算、随机模拟等诸多数学和工
程领域。和Python的列表相比, NumPy数组在运行速度上拥有明显的优势。NumPy底层使用C语言编写,内置
并行运算功能,并且内部解除了GIL (GlobalInterpreter Lock,全局解释器锁),这意味着NumPy在运行速度
和并行计算方面有着先天优势。
    ·NumPy对数组的操作速度不受Python解释器的限制。
    ·当系统有多个CPU时, NumPy可以自动进行并行计算。
    
    NumPy的数据组织结构,尤其是多维数组类(numpy.ndarray),几乎已经成为所有数据处理与机器学习的
标准数据结构。越来越多基于Python的机器学习和数据处理软件包开始使用NumPy数组,虽然这些软件包通常
都支持Python列表作为参数,但它们在处理之前还是会将输入的Python列表转换为NumPy数组,而且输出也通
常为NumPy数组。在Python的阵营里,NumPy的重要性和普遍性日趋增强。换句话说,为了高效地使用机器学习
和数据处理等基于Python的工具包,只知道如何使用Python列表是不够的,还需要知道如何使用NumPy数组。

    4.1 NumPy概览
    NumPy是SciPy家族的成员之一。 SciPy家族是一个专门应用于数学、科学和工程领域的开源Python生态
圈,其家族成员如图4-1所示。SciPy家族的核心成员为Matplotlib、 SciPy和NumPy,可以概括为MSN这三个
字母。
    NumPy的核心是多维数组类numpy.ndarray,矩阵类numpy.matrix是多维数组类的派生类。
以多维数组类为数据组织结构, NumPy提供了众多的数学、科学和工程函数。此外, NumPy还提供了以下多个
子模块。

    ·numpy.random :随机抽样子模块。
    ·numpy.linalg :线性代数子模块。
    ·numpy.f :傅里叶变换子模块。
    ·numpy.ctypeslib :C-Types外部函数接口子模块
    ·numpy.emath:具有自动域的数学函数子模块。
    ·numpy.testing :测试支持子模块。
    ·numpy.matlib:矩阵库子模块。
    ·numpy.dual: SciPy加速支持子模块。
    ·numpy.distutils: 打包子模块。

    本章将在最后一节讲解随机抽样子模块,而线性代数子模块和傅里叶变换子模块因为和SciPy工具包的内
容重复,所以在本书第7章中进行详细讲解。其他子模块因为使用频率较低本书就不再一展开讲解,感兴趣的读
者可以自行查阅相关文档。

    4.1.1安装和导入
    NumPy的安装非常简单,可以使用pip命令直接安装。安装时还可以使用一选择版本号,使用i参数选择下载
速度更快的镜像源。这些基础知识在第1章中已有详细说明。
    python -m pip install numpy
    导入NumPy时写成import numpy as np是程序员约定俗成的规则。在后面的讲解中,涉及命名空间时可
能会混用np和numpy两种写法。
# import numpy as np

    Python的列表操作非常灵活,特别是引入负数索引后,更是为列表操作注入了“神奇的力量”。每一位程序
员第一次使用Python列表时,都会被它的便捷所打动。
    
    首先, Python列表的元素类型不受限制,同一个列表内,列表元素可以是不同的数据类型,甚至可以是函数
。
    其次, Python列表的元素可以动态增减。例如, append()方法可以向列表末尾追加元素,insert()方法可
以在指定位置插入元素, pop()方法可以删除指定索引的元素, remove()方法可以删除指定的元素。
    最后, Python列表的索引非常简单、灵活、高效。例如, [:-1]可以取得最末位的元素,[1:-1]可以返
回“指头去尾”后的列表, [::-1]可以反转列表,[::2]可以隔一个取一个元素。
    NumPy数组的操作便捷性,比Python列表更是有过之而无不及,并且还提供了大量的函数,但同时也增加了
限制: 一是数组元素必须具有相同的数据类型;二是数组一旦创建,其元素数量就不能再改变了。
    说到这里,你也许会问:既然NumPy数组有这些限制条件,那我们为什么还要使用它呢?
答案是, NumPy数组具有极高的、接近C语言的运行效率,同时又继承了Python列表操作便捷、灵活的特点,可
以说NumPy数组是专为处理科学数据而生的。

    4.1.3数组的数据类型
    NumPy支持的数据类型主要有整型(integer)、浮点型(float)、布尔型(bool)和复数型(complex),每
一种数据类型根据占用内存的字节数又分为多个不同的子类型,具体的数据类型如图4-2所示。事实上, 
NumPy也支持字符串类型和自定义类型的数据,但绝大多数函数和方法不适用于非数值型数组。

    创建数组时,如果不指定数据类型, NumPy会根据输入的参数自动选择合适的数据类型通常在指定数据类
型的时候,可以省略类型后面的数字,如果省略数字,整型和无符号整型数认是32位,浮点型默认是64位,复数型
默认是128位。
    下面的代码以交互方式生成数组并显示其数据类型。
"""

# import numpy as np
# a = np.array([0, 1, 2]) # array：数组
# print(a.dtype) # dtype：数据类型：datatype
# int32

# a = np.array([0, 1, 2.0])
# print(a.dtype)
# float64

# a = np.array([0, 1, 2], dtype=np.uint8)
# print(a.dtype)
# uint8 整型的一种

""" 使用正确的数据类型很重要。在图像处理、三维显示等领域,如果数据类型不正确就可能得不到正确的
结果,并且很多情况下没有任何错误提示。例如,使用NumPy数组处理图像时,数据类型一般都必须指定为
np.int8类型。"""

"""
    4.1.4数组的属性
    在上面的交互操作中,我们用数组的dtype属性查看数组的数据类型。除了dtype属性,数组对象还有一些
其他的属性,如shape属性表示数组的结构或叫作形状; size属性表示数组元素个数: itemsize属性表示数
组元素字节数: flags属性表示数组的内存信息: real属性表示数组实部;
imag属性表示数组虚部; data属性表示实际存储区域内存的起始地址,相当于指针。数组的更多属性可通过
表4-1查看。属性看起来有点多,但只需要记住dtype和shape这两个属性就足够了。这两个属性非常重要,重
要到可以忽略其他属性。

    表4-1数组属性速查表
      属性               说明
    ndarray.dtype：    数组的数据类型
    ndarray.shape：    数组的结构,也可以理解为数组的形状 shape:形状
    ndarray.size：     数组的元素个数
    ndarray.itemsize： 每个元素占用内存的大小,以字节为单位
    ndarray.ndim：     数组的维度数,也叫秩
    ndarray.flags ：   数组的内存信息
    ndaray.real：      数组的实部
    ndarray.imag：     数组的虚部
    ndarray.data：     数组在内存中实际存储区域的起始地址


    4.1.5 数组的方法
    在Python基础语法中,我们介绍过列表对象有追加、插入等多种方法,相比之下,数组对象的内置方法更多,尤
其是统计方法,简直多到令人眼花缭乱。不过,我们完全不用担心学不会的问题,学习是循序渐进的, 目前只需要记
住两个方法就行: ndarray.astype()和 ndarray.reshape(),。前者可以修改元素类型,后者可以重新定义数组
的结构。这两个方法的重要性和其对应的属性一样。记住ndarray.dtype ndarray.shape两个属性及其对应的修
改数据类型和数组结构的两个方法,有助于在调试代码时快速定位问题。

    下面的代码以交互方式演示了如何修改数组结构和数据类型。"""

# 数组结构：https://blog.csdn.net/duanlianvip/article/details/94393763
# import numpy as np
# a = np.arange(6) # arange:整理 方法
# print(a)
# # [0 1 2 3 4 5] # 一维数组
# print(a.shape) # 数组a的形状
# # (6,) # 值为6，因为有6个数据
# print(a.dtype)
# # int32 # 整型默认为int32位
# a = a.reshape((2,3)) # 修改数组结构:改为2维数组
# print(a)
# # [[0 1 2]
# #  [3 4 5]]
# a = a.astype(np.float) # 改变数据类型为浮点型
# print(a.dtype)
# float64 # float默认为64位

"""
    4.1.6维、秩、轴
    维,就是维度。通常说数组是几维的,就是指维度数,如三维数组的维度数就是3。维度数还有一个专用名字,
即秩,也就是数组属性ndim。秩这个名字感觉有些多余,不如维度数更容易理解。但是轴的概念大家一定要建立起
来,并且要理解,因为轴的概念很重要。简单来说,我们可以把数组的轴和笛卡儿坐标系的轴来对应一下,示意图如
图4-3所示。一维数组,类比于一维空间,只有一个轴,那就是0轴。二维数组,类比于二维空间,有两个轴,习惯表示
成行和列,行的方向是0轴,列的方向是1轴。三维数组,类比于三维空间,有三个轴,习惯表示成层、行和列,层的方
向是0轴,行的方向是1轴,列的方向是2轴。
    下面用一个三维数组求总和与分层求和的例子来演示一下轴概念的重要性。我们知道,列表求和需要使用
Python内置的求和函数sum(),且只能对数值型的一维列表求和。而数组则是自带求和方法,且支持按指定轴的方
向求和,其代码如下。"""

# import numpy as np
#
# a = np.arange(18).reshape((3,2,3)) # 3层2行3列的结构
# print(a)
# # [[[ 0  1  2]
# #   [ 3  4  5]]
# #
# #  [[ 6  7  8]
# #   [ 9 10 11]]
# #
# #  [[12 13 14]
# #   [15 16 17]]]
# print(a.sum()) # 全部数组元素之和
# # 153
# print(a.sum(axis=0)) # 0轴方向求和：3层合并成1层，返回二维数组
# # [[18 21 24]
# #  [27 30 33]]
# print(a.sum(axis=1)) # 1轴方向求和：2行合并为1行，返回二维数组
# # [[ 3  5  7]
# #  [15 17 19]
# #  [27 29 31]]
# print(a.sum(axis=2)) # 2轴方向求和：3列合并成1列，返回二维数组
# # [[ 3 12]
# #  [21 30]
# #  [39 48]]
#
# print(a.sum(axis=1).sum(axis=1)) # 分层求和方法1
# # [15 51 87]
# print(a.sum(axis=2).sum(axis=1)) # 分层求和方法2
# # [15 51 87]

"""
    4.1.7 广播和矢量化
    前面介绍过, NumPy数组具有极高的、接近C语言的运行效率,处理速度远比Python列表快得多。为什么数组
比列表的处理速度快呢?原来, ndarray拥有区别于列表的两大“独门绝技":广播(broadcast)和矢量化
(vectorization)。广播可以理解为隐式地对每个元素实施操作;矢量化可以理解为代码中没有显式的循环、索引
等。广播和矢量化对于初学者而言有点抽象,下面我们用两个例子来说明一下。

    例1 数值型数组的各个元素加1
    使用Python列表实现列表的各个元素加1,似乎除了循环就没有更好的办法了。当然,如果你想到了用map()函
数来实现,说明你有扎实的基本功,但这个方法只是避免显式地使用循环,实际处理速度不会比循环更快。"""

# a = [0, 1, 2, 3, 4]
# for i in range(len(a)):
#     a[i] += 1
# print(a)
# [1, 2, 3, 4, 5]

""" 如果换成NumPy数组，利用其广播特性，无需循环就可以实现对数组每一个元素加1的操作，其代码如下。
数组的广播特性，不仅省略了循环结构，更重要的是可以大幅加快数据的处理速度。"""

# import numpy as np
#
# a = np.array([0, 1, 2, 3, 4])
# a += 1
# print(a)
# [1 2 3 4 5]

"""
    例2两个等长的数值型数组的对应元素相加
    如果两个等长的Python列表对应元素相加,需要同时遍历两个列表,单是想把代码写“漂亮”就需要花一点心思。
下面的代码使用zip()函数,辅以列表推导式,实现两个等长Python列表的对应元素相加。虽然代码形式上接近
“完美”,但是运行效率仍然很低。"""

# import numpy as np
#
# a = [0, 1, 2, 3, 4]
# b = [5, 6, 7, 8, 9]
# print([i+j for i, j in zip(a, b)])
# # [5, 7, 9, 11, 13]
# 预感训练一百题列出了关于zip()函数专栏

""" 如果换成NumPy数组，利用其矢量化特性来实现两个数组对应元素相加，就像是进行两个整型变量相加，代码
可读性强、处理速度快、其代码如下："""

# import numpy as np
#
# a = np.array([0, 1, 2, 3, 4])
# b = np.array([5, 6, 7, 8, 9])
# print(a + b)
# [ 5  7  9 11 13]

""" 上面的两个例子分别用列表和数组的方式给出了答案。显然，用NumPy数组实现起来要比用Python列表更直
观、更简洁。这正是得益于NumPy的两大特性：广播和矢量化。广播和矢量化是NumPy最“精髓”的特性，是NumPy
的灵魂。广播和矢量化体现在代码上则有以下几个特点：

    · 矢量化代码更简洁，更易于阅读。
    · 代码行越少意味着出错的概率越小。
    · 代码更接近标准的数学符号。
    · 矢量化代码更pythonIC（意思是更有Python的“味道”）。"""












