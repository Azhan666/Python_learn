# !/usr/bin/env python
# -*- coding: utf-8 -*-
"""4.3 操作数组"""

""" 数组的索引和切片、合并与拆分、复制和排序、查找和筛选，以及改变数组结构、数组I/O等，这些是数组
操作的基本技术。其中最抽象的是查找和筛选，但这也是数组操作中最重要、最精髓的一部分。在数组操作中
用好查找和筛选才能避免使用循环，这是数组操作的最高境界。"""

"""4.3.1 索引和切片
    索引是定位一维或多维数组中的单个或多个元素的行为模式，切片是返回一维或多维数组中的单个或多个
相邻元素的视图，目的是引用或赋值。NumPy数组对象的内容可以通过索引或切片来访问和修改。对于一维数组
的索引和切片，NumPy数组使用起来和Python的列表一样灵活。"""

# import numpy  as np
#
# a = np.arange(9)
# print(a[-1]) # 最后一个元素
# # 8
# print(a[2:5]) # 返回第2到第5个元素
# # [2 3 4]
# print(a[:7:3]) # 返回第0到第7个元素，步长为3
# # [0 3 6]
# print(a[::-1]) # 返回逆序的数组
# # [8 7 6 5 4 3 2 1 0]

""" 对于多维数组操作，NumPy数组比Python的列表更加灵活、强大。假设有一栋楼，共2层，每层的房间都
是3行4列，那我们可以用一个三维数组来保存每个房间的居住人数（也可以是房间面积等其它数值信息）。"""

# import numpy as np
#
# a = np.arange(24).reshape(2,3,4) # 2层3行4列
# # print(a)
# # [[[ 0  1  2  3]
# #   [ 4  5  6  7]
# #   [ 8  9 10 11]]
# #
# #  [[12 13 14 15]
# #   [16 17 18 19]
# #   [20 21 22 23]]]
#
# print(a[1][2][3]) # 虽然可以这样索引
# # 23
# print(a[1,2,3]) # 但这样才是规范的用法
# # 23
# print(a[:,0,0]) # 所有楼层的第0行第0列
# # [ 0 12]
# print(a[0,:,:]) # 1层的所有房间，等价于a[0]或a[0,...]
# # [[ 0  1  2  3]
# #  [ 4  5  6  7]
# #  [ 8  9 10 11]]
#
# print(a[:,:,1:3]) # 所有楼层所有排的第1列到第3列
# # [[[ 1  2]
# #   [ 5  6]
# #   [ 9 10]]
# #
# #  [[13 14]
# #   [17 18]
# #   [21 22]]]
#
# print(a[1,:,-1]) # 第1层每一排的最后一个房间
# # [15 19 23]

""" 从上面的代码可以看出，对多维数组索引或切片得到的结果的维度不是确定的。另外还有一点需要特别
提醒：切片返回的数组不是原始数据的副本，而是指向与原始数组相同的内存区域。数组切片不会复制内部
数组数据，只是产生了原始数据的一个新视图。"""

# import numpy as np
#
# a = np.arange(12).reshape(3,4)
# print(a)
# # [[ 0  1  2  3]
# #  [ 4  5  6  7]
# #  [ 8  9 10 11]]
#
# b = a[1:,2:] # 数组b是数组a的切片
# print(b)
# # [[ 6  7]
# #  [10 11]]
#
# b[:,:] = 99 # 改变数组b的值，也会同时影响数组a
# # 切片返回的数组不是原始数据的副本，而是指向与原始数组相同的内存区域
# # 所以数组a的内存区域也受影响
# print(b)
# # [[99 99]
# #  [99 99]]
# print(a)
# # [[ 0  1  2  3]
# #  [ 4  5 99 99]
# #  [ 8  9 99 99]]

""" 上面的代码中，数组b是数组a的切片，当改变数组b的元素时，数组a也同时发生了改变。
这就证明了切片返回的数组不是一个独立的数组，而是指向与原始数组相同的内存区域。"""

"""4.3.2 改变数组结构
    NumPy 之所以拥有极高的运算速度，除了并行、广播和矢量化等技术因素外，其数组存储顺序和
数组视图相互独立也是一个很重要的原因。正因为如此，改变数组结构自然是非常便捷的操作。改变
数组结构的操作通常不会改变所操作的数组本身的存储顺序，只是生成了一个新的视图。np.resize()
函数是个例外，以下是改变数组结构的几个常用函数。

    · ndarray.reshape(): 按照指定的结构（形状）返回数组的新视图，不会改变原数组。
    · ndarray.ravel(): 返回多维数组一维化的视图，不改变原数组
    · ndarray.transpose(): 返回行变列的视图，不改变原数组
    · ndarray.resize(): 按照指定的结构（形状）改变原数组，无返回值
    · numpy.rollaxis(): 翻滚轴，返回新的视图，不改变原数组
    
    如果你足够细心，读到这里也许会产生些许疑惑：为什么前面的几个函数都是ndarray的方法，
而翻滚轴函数numpy.rollaxis()确是numpy的呢？这是命名空间的问题，并且NumPy在命名空间问
题上的却有些含糊不清。不过不用担心，在下一节会专门解释这个问题。下面继续演示这几个改变数
组结构的函数的用法。"""

import numpy as np

# a = np.arange(12)
# b = a.reshape((3,4)) # reshape()函数返回数组a的一个新视图，但不会改变数组a
# print(a.shape) # reshape:重新塑造
# # (12,)
# print(b.shape)
# # (3, 4)
# print(b is a)
# # False
# print(b.base is a)
# # True
# a.resize([4,3]) # resize()函数没有返回值，但真正改变了数组a的结构
# print(a.shape)
# # (4, 3)
# print(a.ravel()) # 返回多维数组一维化的视图，但不会改变原数组
# # [ 0  1  2  3  4  5  6  7  8  9 10 11] # ravel：散开，解开
# print(a.transpose()) # 返回多维数组一维化的视图，但不会改变原数组
# # transpose：调换；移项；颠倒顺序
# # [[ 0  3  6  9]
# #  [ 1  4  7 10]
# #  [ 2  5  8 11]]
#
# print(a.T) # 返回行变列的视图，等价于transpose()函数
# # [[ 0  3  6  9]
# #  [ 1  4  7 10]
# #  [ 2  5  8 11]]
#
# print(np.rollaxis(a, 1, 0)) # 翻滚轴，1轴变0轴 # rollaxis:倾侧轴
# # [[ 0  3  6  9]
# #  [ 1  4  7 10]
# #  [ 2  5  8 11]]

""" 翻滚轴有一个很容易理解的应用，就是用它来实现图像的通道分离。下面的代码生成了一个宽度为800
像素、高为600像素的彩色随机噪声图，使用翻滚轴函数可以将其分离成RGB三个颜色通道。最后两行代码
导入pillow模块，从而可以直观的看到这幅噪声图。"""

# img = np.random.randint(0, 256, (600, 800, 3), dtype=np.uint8)
# print(img.shape)
# # (600, 800, 3)
# r, g, b = np.rollaxis(img, 2, 0) # 将图像数据分离成RGB三个颜色通道
# print(r.shape, g.shape, b.shape)
# # (600, 800) (600, 800) (600, 800)
# from PIL import Image # 导入pillow模块的Image
# print(Image.fromarray(img).show()) # 显示随机生成的噪声图

"""4.3.3 合并
    NumPy数组一旦创建就不能再改变其元素数量。如果要动态改变数组元素数量，只能通过合并或拆分
的方法生成新的数组。对于刚上手NumPy的程序员来说，最大的困惑就是不能使用append()函数像数组内
添加元素，甚至都找不到append()函数。其实，NumPy仍然保留了append()函数，只不过这个函数不再
是数组的函数，而是升级到最外层的NumPy命名空间了，并且该函数的功能不再是追加元素，而是合并数组，
其代码如下："""

# import numpy as np
#
# print(np.append([[1, 2, 3]], [[4, 5, 6]]))
# # [1 2 3 4 5 6]
# print(np.append([[1, 2, 3]], [[4, 5, 6]], axis=0))
# # [[1 2 3]
# #  [4 5 6]]
# print(np.append([[1, 2, 3]], [[4, 5, 6]], axis=1))
# # [[1 2 3 4 5 6]]

""" 不过，append()函数还不够好用，推荐使用stack()函数机及其“同门小兄弟”：hstack()水平合并
函数、vstack()垂直合并函数和dstack()深度合并函数。下面演示这三个函数的用法。"""

# import numpy as np
#
# a = np.arange(4).reshape(2,2)
# b = np.arange(4,8).reshape(2,2)
# print(np.hstack((a,b))) # 水平合并
# # [[0 1 4 5]
# #  [2 3 6 7]]
# print(np.vstack((a,b))) # 垂直合并
# # [[0 1]
# #  [2 3]
# #  [4 5]
# #  [6 7]]
# print(np.dstack((a,b))) # 深度合并
# # [[[0 4]
# #   [1 5]]
# #
# #  [[2 6]
# #   [3 7]]]

""" stack()函数使用axis轴参数指定合并的规则，请仔细阅读体会下面例子中axis轴参数的用法。"""

# import numpy as np
#
# a = np.arange(60).reshape(3,4,5)
# b = np.arange(60).reshape(3,4,5)
# print(a.shape, b.shape)
# print(np.stack((a,b), axis=0).shape) # 0轴
# # (2, 3, 4, 5)
# print(np.stack((a,b), axis=1).shape) # 1轴
# # (3, 2, 4, 5)
# print(np.stack((a,b), axis=2).shape) # 2轴
# # (3, 4, 2, 5)
# print(np.stack((a,b), axis=3).shape) # 3轴
# # (3, 4, 5, 2)

""" 4.3.4 拆分
    因为数组切片非常简单，所以数组拆分应用较少。拆分是合并的逆过程，最常用的函数是split(),
其代码如下："""

# import numpy as np
#
# a = np.arange(16).reshape(2,4,2)
# print(np.hsplit(a, 2)) # 水平方向拆分为2部分
# # [array([[[ 0,  1],
# #         [ 2,  3]],
# #
# #        [[ 8,  9],
# #         [10, 11]]]), array([[[ 4,  5],
# #         [ 6,  7]],
# #
# #        [[12, 13],
# #         [14, 15]]])]
#
# print(np.vsplit(a, 2)) # 垂直方向拆分为2部分
# # [array([[[0, 1],
# #         [2, 3],
# #         [4, 5],
# #         [6, 7]]]), array([[[ 8,  9],
# #         [10, 11],
# #         [12, 13],
# #         [14, 15]]])]
# print(np.dsplit(a, 2)) # 深度方向拆分为2部分
# # [array([[[ 0],
# #         [ 2],
# #         [ 4],
# #         [ 6]],
# #
# #        [[ 8],
# #         [10],
# #         [12],
# #         [14]]]), array([[[ 1],
# #         [ 3],
# #         [ 5],
# #         [ 7]],
# #
# #        [[ 9],
# #         [11],
# #         [13],
# #         [15]]])]

"""4.3.5 复制
    改变数组结构返回的是原数组的一个新视图，而不是原数组的副本。浅复制（view）和深复制（copy）
则是创建原数组的副本，但二者之间也有细微差别：浅复制（view）是共享内存，深复制（copy）是独享
内存，其代码如下："""
# import numpy as np
#
# a = np.arange(6).reshape((2,3))
# b = a.view()
# print(b is a)
# # False
# print(b.base is a)
# # False
# print(b.flags.owndata)
# # False
# c = a.copy()
# print(c is a)
# # False
# print(c.base is a)
# # False
# print(c.flags.owndata)
# # True

"""4.3.6 排序
    NumPy数组有两个排序函数，一个是sort(),另一个是argsort().sort()函数返回输入数组的排序
副本，argsort()函数返回的是数组从小到大的索引号。从函数原型看，这两个函数的参数完全一致。
    numpy.sort(arr, axis=-1, kind='quicksort', order=None)
    numpy.agrsort(arr, axis=-1, kind='quicksort', order=None)
    
    第1个参数arr,是要排序的数组，第2个参数axis，也就是轴，默认值-1表示没有指定排序轴，返回
结果将沿着最后的轴排序，第3个参数kind，表示排序方法1，默认为‘quicksort’(快速排序)，其他选项
还有“mergesort”（归并排序）和“heapsort”（堆排序），第4个参数order，指定用于排序的字段，前
提是数组包含该字段。"""

# import numpy as np
#
# a = np.random.random((2,3))
# print(a)
# # [[0.62162068 0.54276178 0.76379175]
# #  [0.33827306 0.68980873 0.03522846]]
# print(np.argsort(a)) # 返回行内从小到大的索引号（列排序），相当于axis=1(最后的轴)
# # [[1 0 2]
# #  [2 0 1]]
#
# print(np.sort(a)) # 返回行内从小到大排序的新数组（列排序）
# # [[0.23754189 0.31986319 0.61762582]
# #  [0.26639182 0.33755194 0.57678219]]
# print(np.sort(a, axis=0)) # 返回列内从小到大排序的新数组（行排序）
# # [[0.32037615 0.38966215 0.40363066]
# #  [0.90503688 0.99926645 0.70252905]]

""" 下面演示的是排序字段的使用。先定义一个新的数据类型dt,类似于一个字典，有姓名name和年龄age,
两个键值对，姓名的长度为10个字符，年龄的数据类型是整型。"""

# import numpy as np
#
# dt = np.dtype([('name', 'S10'),('age', int)])
# a  = np.array([("zh",21),("wang",25),("li",20),("zhao",19)], dtype = dt)
# print(np.sort(a, order='name')) # 如果指定姓名排序，结果是李王张赵
# # [(b'li', 20) (b'wang', 25) (b'zh', 21) (b'zhao', 19)]
# print(np.sort(a, order='age')) # 如果指定年龄排序，结果是赵李张王
# # [(b'zhao', 19) (b'li', 20) (b'zh', 21) (b'wang', 25)]

"""4.3.7 查找
    这里约定查找是返回数组中符合条件的元素的索引号，或返回和数组具有相同结构的布尔型数组，
元素符合条件在布尔型数组中对应的True，否则对应False。查找分为最大值和最小值查找、非零元
素查找、使用逻辑及表达式查找和使用where条件查找这4种方式。"""

""" 1. 最大值和最小值查找
    下面的代码演示了返回数组中最大值和最小值的索引号，如果是多维数组，这个索引号是数组转为
一维数组之后的索引号。"""

# import numpy as np
#
# a = np.random.random((2,3))
# print(a)
# [[0.97636132 0.34159529 0.77447187]
#  [0.62154082 0.42862738 0.89747354]]
# print(np.argmax(a))
# 0
# print(np.argmin(a))
# 1

""" 2. 非零元素查找
    下面的代码演示了返回数组中非零元素的索引号，返回的结果是一个元组。"""

# import numpy as np
# a = np.random.randint(0, 2, (2,3))
# print(a)
# # [[0 0 1]
# #  [0 0 0]]
# print(np.nonzero(a))
# # # (array([0], dtype=int64), array([2], dtype=int64))# (array([0], dtype=int64), array([2], dtype=int64))

"""3. 使用逻辑表达式查找
    下面的代码演示了使用逻辑表达式查找符合条件的元素，返回结果是一个和原数组结构相同的布尔型
数组，元素符合条件在布尔型数组中对应True，否则对应False。"""

# import numpy as np
#
# a = np.arange(10).reshape((2,5))
# print(a)
# # [[0 1 2 3 4]
# #  [5 6 7 8 9]]
# print((a>3)&(a<8))
# # [[False False False False  True]
# #  [ True  True  True False False]]

"""4. 使用where条件查找
    np.where()函数返回数组中满足给定条件的元素的索引号，其结构为元组，元组的第k个元素对应符合
条件的元素在数组k轴上的索引号。这句话可以简单理解为：一维数组返回一个元素的元组，二维数组返回
两个元素的元组，以此类推。np.where()函数还可以用于替换符合条件的元素。"""

# import numpy as np
#
# a = np.arange(10)
# print(a)
# # [0 1 2 3 4 5 6 7 8 9]
# print(np.where(a < 5))
# # (array([0, 1, 2, 3, 4], dtype=int64),)
# a = a.reshape((2, -1))
# print(a)
# # [[0 1 2 3 4]
# #  [5 6 7 8 9]]
# print(np.where(a < 5))
# # (array([0, 0, 0, 0, 0], dtype=int64), array([0, 1, 2, 3, 4], dtype=int64))
# print(np.where(a < 5, a, 10*a)) # 满足条件的元素不变，其他元素乘10
# # [[ 0  1  2  3  4]
# #  [50 60 70 80 90]]

""" 4.3.8 筛选
    筛选是返回符合条件的元素。筛选的条件有三种表达方式，一是使用np.where()函数返回的Python
元组，二是使用逻辑表达式返回的布尔型数组，三是使用整型数组，其代码如下："""

# import numpy as np
#
# a = np.random.random((3,4))
# print(a)
# # [[0.86642136 0.19223119 0.2487603  0.69002217]
# #  [0.77462797 0.98040062 0.60733275 0.36366406]
# #  [0.59886963 0.32286959 0.09623784 0.69474764]]
# print(a[np.where(a > 0.5)]) # 返回大于0.5的元素（使用where()函数返回的Python元组）
# # [0.86642136 0.69002217 0.77462797 0.98040062 0.60733275 0.59886963
# #  0.69474764]
# print(a[(a > 0.3)&(a < 0.7)]) # 返回大于0.3且小于0.7的元素（使用逻辑表达式返回的布尔型数组）
# # [0.69002217 0.60733275 0.36366406 0.59886963 0.32286959 0.69474764]
# # [[0.59886963 0.32286959 0.09623784 0.69474764]
# print(a[np.array([2,1])]) # 返回整型数组指定的项（使用整型数组）
#
# a = a.ravel()
# # print(a[np.array([3,5,7,11])]) # 返回整型数组指定的项（使用整型数组）
# # [0.77462797 0.98040062 0.60733275 0.36366406]]
# # [0.69002217 0.98040062 0.36366406 0.69474764]
# print(a[np.array([[3,5],[7,11]])]) # 返回整型数组指定的项（使用整型数组）
# # [[0.69002217 0.98040062]
# #  [0.36366406 0.69474764]]

""" 使用np.where()函数或直接使用逻辑表达式来筛选数组元素，其目的是从数组中筛选出符合条件的元素。
那么，使用整型数组来筛选数组元素的用途是什么呢？一个看似不起眼的功能，运用起来其实蕴含着无穷的想
象空间。下面用一个例子来演示通过整型数组筛选数组元素的神奇魔法。图4-5所示的是用字符表现像素的
灰度图。"""

""" 
    一般而言,灰度图像每个像素的值域范围是[0, 255],假如用于表现不同灰度的字符集是['',',','-''+','*'
,'#''=','@',]从''到'@'表示从白到黑的8个灰度等级。我们需要将每个像素的灰度值分段转换成相应的字符。
例如,灰度值小于32的像素用'@',表示,大于或等于32且小于64的像素用'#'表示,依次类推直至大于或等于224的
像素用''表示。
    如何实现图像数组从灰度值到对应字符的转换呢?乍一看,好像只有用循环的方式遍历所有像素才能实现。但是
,下面的代码却用“整型数组筛选数组元素”的方法完成了这个转换不但代码简洁,而且代码的执行速度也非常快。
"""

# import numpy as np
#
# img = np.random.randint(0, 256, (5, 10), dtype=np.uint8)
# print(img)
# # [[ 73 134 237 155 223 193  86  87 204 129]
# #  [ 68  80  28 213  65 206   1 105  80  82]
# #  [154  40 142  78  56 125 125 216  14  51]
# #  [178 105 180   8 158 179  49 185 255 112]
# #  [234 118 220  33  82  60  15  90  10 162]]
#
# img = (img/32).astype(np.uint8) # 将256级灰度值转为8级灰度值
# print(img)
# # [[2 4 7 4 6 6 2 2 6 4]
# #  [2 2 0 6 2 6 0 3 2 2]
# #  [4 1 4 2 1 3 3 6 0 1]
# #  [5 3 5 0 4 5 1 5 7 3]
# #  [7 3 6 1 2 1 0 2 0 5]]
# chs = np.array([' ','.','-','+','*','#','=','@',]) # 灰度字符集
# print(chs[img]) # 用整型数组筛选数组元素（我认为这是NumPy最精彩之处！）
# # [['-' '*' '@' '*' '=' '=' '-' '-' '=' '*']
# #  ['-' '-' ' ' '=' '-' '=' ' ' '+' '-' '-']
# #  ['*' '.' '*' '-' '.' '+' '+' '=' ' ' '.']
# #  ['#' '+' '#' ' ' '*' '#' '.' '#' '@' '+']
# #  ['@' '+' '=' '.' '-' '.' ' ' '-' ' ' '#']]

"""用字符表示像素的灰度"""

"""4.3.9 数组I/O
    数组I/O就是讨论如何分发、交换数据。在机器学习算法模型的例子中，海量的训练数据通常都是从数据文件中读取
出来的，而数据文件一般是CSV格式。NumPy自带CSV格式文件读取函数，可以很方便的读写CSV格式的数据文件。除了支
持通用的CSV格式的数据文件，NumPy还为数组对象引入了两个新的二进制文件格式，用于数据交换。扩展名为.npy的数
据文件用于存储单个数组，扩展名为.npz的数据文件用于存储多个数组。NumPy支持的数据文件格式及读写函数的对应
关系具体如图4-6所示。

    CSV是一种通用的、相对简单的文件格式。CSV格式的数据文件以纯文本形式存储表格数据，由任意数目的记录组成，
记录间以某种换行符分隔。每条记录由字段组成，字段间的分隔符是其他字符或字符串，最常见的是逗号或制表符。通常
，所有记录都有完全相同的字段序列。下面的代码演示了NumPy读写CSV格式的数据文件的方法。实际操作下面的代码时，
请注意结合实际情况替换对应的文件路径和文件名。"""

# import numpy as np
#
# a = np.random.random((15,5))
# np.savetxt('demo.csv', a, delimiter=',') # 将数组a保存成CSV格式的数据文件
# data = np.loadtxt('demo.csv', delimiter=',') # 打开CSV格式的数据文件 # load:加载
# print(data.shape, data.dtype)
# # (15, 5) float64

"""NumPy自定义的数据交换格式也是一个非常好用的数据交换方式，使用它保存NumPy数组时不会丢失任何信息，特别是
数据类型的信息。实际操作下面的代码时，请注意结合实际情况替换对用的文件路径和文件名。"""

# import numpy as np
#
# single_arr_fn = 'single_arr_npy' # 存储单个数组文件名
# multi_arr_fn = 'multi_arr_npz' # 存储多个数组文件名
# lon = np.linspace(10,90,9)
# lat = np.linspace(20,60,5)
# np.save(single_arr_fn, lon) # 用save()函数把经度数组保存成.npy文件
# lon = np.load(single_arr_fn) # 接着用load()函数读取出来
# np.savez(multi_arr_fn, logitude=lon, latitude=lat) # 保存两个数组到一个文件
# data = np.load(multi_arr_fn) # 用load()函数把这个.npz文件读成一个结构data
# print(data.files) # 查看所有的数组名
# print(data['lonitude']) # 使用data[数组名]，就可以取得想要的数据
# print(data['latitude']) # 使用data[数组名]，就可以取得想要的数据


























