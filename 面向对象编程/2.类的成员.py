# !/usr/bin/env python
# -*- coding: utf-8 -*-
# 2.3.2 类的成员
# 写在前面：
# 所有的Python类都有构造函数和析构函数。除了这两个成员，类还可以包含成员函数和成员变量，也
# 有很多人喜欢把成员函数称为类的方法，把成员变量称为类的属性。

# 定义类时，即便没有显式地定义构造函数和析构函数，这两个成员也照样存在（析构函数稍微有点特殊，
# 除非是显式定义的，否则不能在类的成员中直接看到他）。如果在类定义时显式地定义了构造函数和析
# 构函数，则它们将会取代系统自动赋予的这两个成员。下面的例子清晰的说明了其中的奥秘：类A既没有
# 构造函数，也没有析构函数，类B只有析构函数。两个类都可以生成类实例，也都可以销毁。当销毁类B
# 的实例时，首先调用了自定义的析构函数，尽管这个析构函数仅仅执行了一个print()函数，并没有销
# 毁操作，但实例仍然被销毁了。

# class A:
#     pass
# a = A()
# del a
# print(a)
#
# class B:
#     def __del__(self):
#         print('执行析构函数，清理现场')
#
# b = B()
# del b
# print(b)

# 下面的例子演示了如何定义成员函数和成员变量。

class A:
    def __init__(self): # 定义构造函数
        self.a = 10 # 定义一个成员变量a
    def getA(self): # 定义成员函数
        print("a=%d" % self.a)

a = A() # 实例化
a.getA()

# -------------------------------------------------
# class Person(): # 创建一个最简单的没有内容的空类
#     pass
# """
#     也可以通过类名来创建对象，同调用函数一样：
# """
# someone = Person()
"""
    Person()创建了一个Person类的对象，并给它赋值someone这个名字。
由于我们的Person是空的，所以由它创建的对象someone实际上什么也做不了。
实际编程中，你永远也不会创建这样一个没用的类。
    
    我们试着重新定义一下Person类，这一次，将Python中特殊的对象初始化方法
__init__放入其中：
"""
# class Person():
#     def __init__(self) -> None:
#         pass
"""
    我承认__init__()和self看起来很奇怪，但这就是实际的Python类的定义形式。
__init__()是Python中一个特殊的函数名，用于根据类的定义创建实例对象。
self残数指向了这个正在被创建的对象本身。
    当你在类声明里定义__init__()方法时，第一个参数必须为self。尽管self并不是一个Python保留字，
但它很常用。没有人（包括你自己）在阅读你的代码时需要猜测使用self的意图。
    尽管我们添加了初始化方法，但用这个Person类创建的对象仍然什么也做不了。即将进行的第三次尝试
要更吸引人了，你将学习如何让创建一个简单可用的Python对象。这一次，会在初始化方法中添加name参数：
"""
class Person():
    def __init__(self, name):
        self.name = name

# 现在，用Person类创建一个对象，为name特性传递一个字符串参数：
hunter = Person('Elmer Fudd')
"""
    上面这短短的一句话实际做了以下工作：

    1.查看Person类的定义；
    2.在内存中实例化（创建）一个新的对象；
    3.调用对象的__init__方法，将这个新创建的对象作为self传入，并将另一个残数（'Elmer 
    Fudd'）作为name传入；
    4.将name的值存入新的对象；
    5.将名字hunter与这个对象关联。

    这个新对象与任何其他的Python对象一样。你可以把它当作列表、元素、字典或集合中的元素，
也可以把它当作残数传递给函数，或者把它作为函数的返回结果。
    我们刚刚传入的name参数此时又在哪呢？它作为对象的特性存储在了对象里。
可以直接对它进行读写操作:
"""
print('The mighty hunter:', hunter.name)
"""
    记住，在Person类定义的内部，你可以直接通过self.name访问name特性。而当创建了一个实际的对象后，
例如这里的hunter，需要通过hunter.name来访问它。
    在类的定义中，__init__并不是必需的。只有当需要区分由该类创建的不同对象时，才需要指定__init__方法。
"""

